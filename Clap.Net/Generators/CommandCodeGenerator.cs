using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Clap.Net.Extensions;
using Clap.Net.Models;
using Clap.Net.Serialisation;
using Microsoft.CodeAnalysis;

namespace Clap.Net.Generators;

internal static class CommandCodeGenerator
{
    /// <summary>
    /// Validates that an environment variable name contains only safe characters.
    /// Throws if the name contains potentially dangerous characters that could lead to code injection.
    /// </summary>
    private static void ValidateEnvironmentVariableName(string envVarName, string argumentName)
    {
        if (string.IsNullOrWhiteSpace(envVarName))
            return;

        // Environment variable names should only contain alphanumeric characters and underscores
        foreach (var c in envVarName)
        {
            if (!char.IsLetterOrDigit(c) && c != '_')
            {
                throw new System.InvalidOperationException(
                    $"Invalid environment variable name '{envVarName}' for argument '{argumentName}'. " +
                    "Environment variable names must contain only letters, digits, and underscores.");
            }
        }

        // Ensure it doesn't start with a digit
        if (char.IsDigit(envVarName[0]))
        {
            throw new System.InvalidOperationException(
                $"Invalid environment variable name '{envVarName}' for argument '{argumentName}'. " +
                "Environment variable names cannot start with a digit.");
        }
    }

    public static void GenerateSourceCode(
        IndentedTextWriter writer,
        SyntaxBuilder syntaxBuilder,
        CommandModel commandModel,
        ImmutableArray<SubCommandModel> subCommandModels,
        string? assembly)
    {
        var namedArgs = commandModel.Arguments.OfType<NamedArgumentModel>().ToArray();
        var positionalArgs = commandModel.Arguments.OfType<PositionalArgumentModel>().ToArray();

        var fullName = commandModel.Symbol.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
        var subCommand = commandModel.SubCommandArgumentModel is { } c
            ? FindSubCommand(c.MemberType, subCommandModels)
            : null;

        WriteCommentHeader(commandModel, writer, syntaxBuilder);

        if (!commandModel.Symbol.ContainingNamespace.IsGlobalNamespace)
            syntaxBuilder.BlockScopeNamespace(commandModel.Symbol.ContainingNamespace);

        using var containerType = commandModel.Symbol.ContainingType is { } containingType
            ? syntaxBuilder.TypeDefinition(containingType)
            : null;

        using var typeBuilder = syntaxBuilder.TypeDefinition(commandModel.Symbol);

        writer.WriteLine("private const string HelpMessage = ");
        writer.Indent++;
        writer.WriteLine("\"\"\"");
        writer.WriteMultiLine(HelpMessageGenerator.GenerateHelpMessage(commandModel, subCommand, namedArgs, positionalArgs));
        writer.WriteLine("\"\"\";");
        writer.Indent--;
        writer.WriteLine();

        GenerateParseResultClass(writer, fullName);
        writer.WriteLine();

        GenerateSpanParseMethod(writer, fullName);
        writer.WriteLine();

        GenerateTokenParseMethod(writer, fullName);
        writer.WriteLine();

        WriteSpanTryParseMethod(typeBuilder, writer, fullName);
        writer.WriteLine();

        WriteTokenTryParseMethod(
            typeBuilder, commandModel, assembly, writer, namedArgs, positionalArgs, fullName, subCommand);
        writer.WriteLine();

        WriteHelperMethods(writer);
    }

    private static void WriteCommentHeader(
        CommandModel commandModel,
        IndentedTextWriter writer,
        SyntaxBuilder syntaxBuilder)
    {
        syntaxBuilder.WriteMultiLineComment(
            $"""
             CAUTION! This code has been generated by the Clap.Net source generator and should not be edited.

             Name: {commandModel.Name}
             About: {commandModel.About}
             Long About: {commandModel.LongAbout}
             """);
        writer.WriteLine();
        syntaxBuilder.WriteNullable();
        writer.WriteLine();
    }

    private static void GenerateParseResultClass(IndentedTextWriter writer, string fullName)
    {
        var resultClassName = ParseResultGenerator.CreateResultClassName(fullName);
        ParseResultGenerator.GenerateParseResultClass(writer, fullName, resultClassName);
    }

    private static void GenerateSpanParseMethod(IndentedTextWriter writer, string fullName)
    {
        writer.WriteMultiLine(
            $$"""
              public static {{fullName}} Parse(System.ReadOnlySpan<string> args)
              {
                  // Protect against DoS attacks with excessive argument counts
                  const int MaxTotalArguments = 50000;
                  if (args.Length > MaxTotalArguments)
                  {
                      throw new System.ArgumentException(
                          $"Total argument count ({args.Length}) exceeds maximum of {MaxTotalArguments}");
                  }

                  var tokens = Clap.Net.ArgsLexer.Lex(args);
                  return Parse(tokens);
              }
              """);
    }

    private static void GenerateTokenParseMethod(IndentedTextWriter writer, string fullName)
    {
        writer.WriteMultiLine(
            $$"""
              public static {{fullName}} Parse(System.ReadOnlySpan<Clap.Net.IToken> tokens)
              {
                  var parseResult = TryParse(tokens);

                  if (parseResult.IsSuccess)
                      return parseResult.Command;

                  if (parseResult.IsVersion)
                  {
                      System.Console.WriteLine(parseResult.Version.Version);
                      System.Environment.Exit(0);
                  }

                  if (parseResult.IsError)
                  {
                      DisplayError(parseResult.Error.Message, parseResult.Error.HelpMessage);
                      System.Environment.Exit(0);
                  }

                  PrintHelpMessage(parseResult.Help.HelpMessage);
                  System.Environment.Exit(0);

                  // Unreachable: all control paths above call Environment.Exit(0)
                  return default!;
              }
              """);
    }

    private static void WriteSpanTryParseMethod(
        TypeSyntaxBuilder typeBuilder,
        IndentedTextWriter writer,
        string fullName)
    {
        var resultClassName = ParseResultGenerator.CreateResultClassName(fullName);

        using var method = typeBuilder.Method(
            BindingFlags.Public | BindingFlags.Static,
            resultClassName,
            "TryParse",
            ["System.ReadOnlySpan<string> args"]);

        writer.WriteLine("var tokens = Clap.Net.ArgsLexer.Lex(args);");
        writer.WriteLine("return TryParse(tokens);");
    }

    private static void WriteTokenTryParseMethod(
        TypeSyntaxBuilder typeBuilder,
        CommandModel commandModel,
        string? assemblyVersion,
        IndentedTextWriter writer,
        NamedArgumentModel[] namedArguments,
        PositionalArgumentModel[] positionalArgs,
        string fullName,
        SubCommandModel? subCommand)
    {
        var resultClassName = ParseResultGenerator.CreateResultClassName(fullName);

        using var method = typeBuilder.Method(
            BindingFlags.Public | BindingFlags.Static,
            resultClassName,
            "TryParse",
            ["System.ReadOnlySpan<Clap.Net.IToken> tokens"]);

        using (method.If("tokens.Length > 0 && tokens[0] is Clap.Net.ShortFlag('h') or Clap.Net.LongFlag(\"help\")"))
            writer.WriteLine("return new Clap.Net.Models.ShowHelp(GetFormattedHelpMessage());");

        writer.WriteLine();

        if ((commandModel.Version ?? assemblyVersion) is { } version)
        {
            var versionFlags = new List<string>();

            if (namedArguments.All(_ => _.Short != 'v'))
                versionFlags.Add("Clap.Net.ShortFlag('v')");

            if (namedArguments.All(_ => _.Long != "version"))
                versionFlags.Add("Clap.Net.LongFlag(\"version\")");

            if (versionFlags.Any())
            {
                writer.Write("if (tokens.Length > 0 && tokens[0] is ");
                writer.Write(string.Join(" or ", versionFlags));
                writer.WriteLine(')');
                writer.WriteMultiLine(
                    $$"""
                      {
                          return new Clap.Net.Models.ShowVersion("{{version}}");
                      }
                      """);
                writer.WriteLine();
            }
        }

        if (commandModel.Arguments.Length is 0 && commandModel.SubCommandArgumentModel is null)
        {
            writer.WriteLine($"return new {fullName}();");
            return;
        }

        foreach (var arg in namedArguments)
        {
            writer.Write($"// Argument '{arg.Symbol.Name}' is a");
            if (arg.Required) writer.Write(" required");
            writer.WriteLine(" named argument");

            var type = arg.MemberType.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
            if (arg.MemberType is INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol)
            {
                var elementType = namedTypeSymbol.TypeArguments.First().ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
                type = $"System.Collections.Generic.List<{elementType}>";
            }

            var initialValue = arg switch
            {
                { DefaultValue: { } value } => $"({type}){value}",
                { Required: true } => $"new Clap.Net.Models.FieldValue<{type}>()",
                _ => $"({type})default"
            };

            string defaultValue;
            if (arg.Env is { } env)
            {
                ValidateEnvironmentVariableName(env, arg.Symbol.Name);
                defaultValue = $"Environment.GetEnvironmentVariable(\"{env}\") is {{ }} env ? ({type}){ArgumentConversionHelper.GetArgConversion(arg.MemberType, "env", arg.ValueParser)} : {initialValue}";
            }
            else
            {
                defaultValue = initialValue;
            }

            writer.WriteLine($"Clap.Net.Models.FieldValue<{type}> {arg.VariableName} = {defaultValue};");
        }

        foreach (var arg in commandModel.Arguments.OfType<PositionalArgumentModel>())
        {
            var type = arg.MemberType.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
            var defaultValue = arg switch
            {
                { DefaultValue: { } value } => $"({type}){value}",
                { Required: true } => $"new Clap.Net.Models.FieldValue<{type}>()",
                _ => $"({type})default!"
            };

            writer.Write($"// Argument '{arg.Symbol.Name}' is");
            if (arg.Required) writer.Write(" a required");
            writer.WriteLine($" positional argument at index {arg.Index}");

            writer.WriteLine($"Clap.Net.Models.FieldValue<{type}> {arg.VariableName} = {defaultValue};");
        }

        if (commandModel.SubCommandArgumentModel is { } subCommandArgument)
        {
            writer.WriteLine();

            var type = subCommandArgument.MemberType.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat).TrimEnd('?');
            var simpleTypeName = type.Substring(type.LastIndexOf('.') + 1);
            var subCommandResultClassName = $"{simpleTypeName.Replace('<', '_').Replace('>', '_')}ParseResult";

            method.SingleLineComment($"SubCommand '{subCommandArgument.Symbol.Name}'");
            writer.WriteLine($"{type}.{subCommandResultClassName}? @__clapgen_subCommand = null;");
        }

        writer.WriteLine();

        if (positionalArgs.Length > 0)
            writer.WriteLine("var positionalIndex = 0;");

        writer.WriteLine("var index = 0;");

        using (var whileBlock = method.WhileStatement("index < tokens.Length"))
        using (var tokenSwitch = whileBlock.SwitchStatement("tokens[index]"))
        {
            if (subCommand is not null)
                GenerateSubCommandCase(writer, tokenSwitch, subCommand);

            GenerateFlagCase(commandModel, tokenSwitch, writer);

            foreach (var argument in commandModel.Arguments)
            {
                switch (argument)
                {
                    case NamedArgumentModel value:
                    {
                        GenerateNamedArgumentCase(writer, fullName, value, argument);
                        break;
                    }

                    case PositionalArgumentModel positional:
                    {
                        GeneratePositionalArgumentModel(writer, fullName, positional);
                        break;
                    }
                }
            }

            using (tokenSwitch.Case("var arg"))
                writer.WriteLine(
                    "return new Clap.Net.Models.ParseError($\"Unknown argument '{Clap.Net.TokenExtensions.Format(arg)}'\", GetFormattedHelpMessage());");
        }

        writer.WriteLine();

        GenerateRequiredArgumentChecks(commandModel, method, writer);

        writer.WriteLine();
        writer.Write("return ");

        using var obj = method.NewObject(fullName);

        foreach (var arg in commandModel.Arguments)
            obj.WriteField(arg.Symbol.Name, $"{arg.VariableName}.Value");

        if (commandModel.SubCommandArgumentModel is not null)
            obj.WriteField(commandModel.SubCommandArgumentModel.Symbol.Name, "@__clapgen_subCommand?.Command");
    }

    private static void GenerateRequiredArgumentChecks(
        CommandModel commandModel,
        BlockSyntaxBuilder syntaxBuilder,
        IndentedTextWriter writer)
    {
        var requiredArguments = commandModel.Arguments
            .Where(a => a.Required)
            .ToArray();

        if (requiredArguments.Length > 0)
        {
            var condition = string.Join(" || ", requiredArguments.Select(a => $"!{a.VariableName}.HasValue"));

            using var ifBlock = syntaxBuilder.If(condition);
            writer.WriteLine("var sb = new System.Text.StringBuilder();");

            foreach (var requiredArg in requiredArguments)
            {
                var name = requiredArg.VariableName;
                switch (requiredArg)
                {
                    case { Symbol: IArrayTypeSymbol }:
                    {
                        using (ifBlock.If($"!{name}.HasValue || {name}.Value.Length is 0"))
                            writer.WriteLine($"sb.AppendLine(\"  <{requiredArg.Symbol.Name}>\");");
                        break;
                    }

                    default:
                    {
                        using (ifBlock.If($"!{name}.HasValue"))
                            writer.WriteLine($"sb.AppendLine(\"  <{requiredArg.Symbol.Name}>\");");
                        break;
                    }
                }
            }

            writer.WriteLine(
                "return new Clap.Net.Models.ParseError($\"The following required arguments were not provided:\\n{sb.ToString()}\", GetFormattedHelpMessage());");
        }
        else
        {
            writer.WriteLine("// No required fields");
        }

        if (commandModel.SubCommandArgumentModel is not { IsRequired: true })
            return;

        using (syntaxBuilder.If("@__clapgen_subCommand is null"))
            writer.WriteLine(
                $"return new Clap.Net.Models.ParseError($\"The subcommand was not provided:\\n{commandModel.SubCommandArgumentModel.Symbol.Name}\", GetFormattedHelpMessage());");
    }

    private static void GeneratePositionalArgumentModel(
        IndentedTextWriter writer,
        string fullName,
        PositionalArgumentModel positional)
    {
        writer.WriteLine($"// Setting attribute '{fullName}.{positional.Symbol.Name}'");
        writer.WriteLine($"case Clap.Net.ValueLiteral valueLiteral when positionalIndex is {positional.Index}:");
        writer.WriteLine("{");
        writer.Indent++;
        SetPositionalValue(writer, positional);
        writer.WriteLine("positionalIndex++;");
        writer.WriteLine("break;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private static void GenerateNamedArgumentCase(
        IndentedTextWriter writer,
        string fullName,
        NamedArgumentModel value,
        ArgumentModel argument)
    {
        var symbolName = value.Symbol.Name.ToSnakeCase();
        var name = value switch
        {
            { Short: { } shortName, Long: { } longName } =>
                $"Clap.Net.ShortFlag('{shortName}') or Clap.Net.LongFlag(\"{longName}\")",
            { Short: { } shortName } => $"Clap.Net.ShortFlag('{shortName}')",
            { Long: { } longName } => $"Clap.Net.LongFlag(\"{longName}\")",
            _ => $"Clap.Net.LongFlag(\"{symbolName}\")"
        };

        writer.WriteLine($"// Setting named argument '{fullName}.{value.Symbol.Name}'");
        writer.WriteLine($"// action '{value.Action.ToString()}'");
        writer.WriteLine($"case {name}:");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("index++;");
        SetNamedArgumentValue(writer, value);
        writer.WriteLine("break;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        if (argument.MemberType.Name is "Boolean"
            && value is { Negation: true, Long: { } l })
        {
            writer.WriteLine($"// Setting attribute '{fullName}.{value.Symbol.Name}'");
            writer.WriteLine($"case Clap.Net.NegatedFlag(Clap.Net.LongFlag(\"{l}\")):");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("index++;");
            writer.WriteLine($"{value.VariableName} = false;");
            writer.WriteLine("break;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
        }
    }

    private static void GenerateSubCommandCase(
        IndentedTextWriter writer,
        SwitchStatementSyntaxBuilder syntaxBuilder,
        SubCommandModel subCommand)
    {
        var type = subCommand.Symbol.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
        writer.WriteMultiLine(
            $"""
            // Setting subcommand '{type}'
            // Command switching swallows the rest of the arguments but previously
            // parsed arguments still get applied to the model
            """);

        var names = new string[subCommand.Commands.Count];
        for (var i = 0; i < subCommand.Commands.Count; i++)
            names[i] = $"\"{subCommand.Commands[i].Name}\"";

        using var caseBlock = syntaxBuilder.Case($"Clap.Net.ValueLiteral({string.Join(" or ", names)})");

        using (var resolveSwitch = caseBlock.SwitchStatement($"{type}.Resolve(tokens[index..])"))
        {
            using (resolveSwitch.Case("{ IsSuccess: true } result"))
            {
                caseBlock.Assignment("@__clapgen_subCommand", "result.Command");
                caseBlock.Break();
            }

            using (resolveSwitch.Case("{ IsHelp: true } help"))
                writer.WriteLine("return help.Help;");

            using (resolveSwitch.Case("{ IsVersion: true } version"))
                writer.WriteLine("return version.Version;");

            using (resolveSwitch.Case("{ IsError: true } error"))
                writer.WriteLine("return error.Error;");
        }

        writer.WriteLine();

        caseBlock.SingleLineComment("Jump to the end of the token list");
        caseBlock.Assignment("index", "tokens.Length");
        caseBlock.Break();
    }

    private static void GenerateFlagCase(
        CommandModel commandModel,
        SwitchStatementSyntaxBuilder switchSyntaxBuilder,
        IndentedTextWriter writer)
    {
        writer.WriteLine("// Handling CompoundFlag");
        using var compountFlagCase = switchSyntaxBuilder.Case("Clap.Net.CompoundFlag(var chars)");

        using (var forEachBlock = compountFlagCase.ForEachBlock("c", "chars"))
        using (var caseStatement = forEachBlock.SwitchStatement("c"))
        {
            foreach (var arg in commandModel.Arguments
                         .OfType<NamedArgumentModel>()
                         .Where(a => a.Short is not null))
            {
                switch (arg.MemberType.Name)
                {
                    case "Boolean":
                    {
                        using (caseStatement.Case($"'{arg.Short!.Value}'"))
                        {
                            writer.WriteLine($"{arg.VariableName} = true;");
                            writer.WriteLine("break;");
                        }

                        break;
                    }

                    case "Int32" or "Int64":
                    {
                        using (caseStatement.Case($"'{arg.Short!.Value}'"))
                        {
                            writer.WriteLine($"{arg.VariableName} = {arg.VariableName}.Value + 1;");
                            writer.WriteLine("break;");
                        }

                        break;
                    }
                }
            }

            using (caseStatement.DefaultCase())
                writer.WriteLine(
                    "return new Clap.Net.Models.ParseError($\"Unexpected flag supplied in compound flags '{c}'\", GetFormattedHelpMessage());");
        }

        writer.WriteLine("index++;");
        writer.WriteLine("break;");
    }

    private static SubCommandModel? FindSubCommand(
        ITypeSymbol member,
        ImmutableArray<SubCommandModel> subCommandModels)
    {
        var memberType = member.ToDisplayString().TrimEnd('?');
        return subCommandModels.FirstOrDefault(sc =>
            memberType == sc?.Symbol.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat).TrimEnd('?'));
    }

    private static void WriteHelperMethods(IndentedTextWriter writer)
    {
        writer.WriteMultiLine(
            """
            public static void DisplayError(string message, string helpMessage)
            {
                var previousColour = System.Console.ForegroundColor;
                System.Console.ForegroundColor = System.ConsoleColor.Red;
                System.Console.WriteLine(message);
                System.Console.ForegroundColor = previousColour;
                System.Console.WriteLine(helpMessage);
            }

            public static void PrintHelpMessage(string helpMessage)
            {
                System.Console.WriteLine(helpMessage);
            }

            private static string GetFormattedHelpMessage()
            {
                var executableName = System.IO.Path.GetFileNameWithoutExtension(System.Environment.GetCommandLineArgs()[0]);
                if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows))
                    executableName += ".exe";
                return HelpMessage.Replace("{{EXECUTABLE_NAME}}", executableName);
            }

            private delegate bool TryParseDelegate<T>(string input, out T result);

            private static T TryParseOrThrow<T>(string input, TryParseDelegate<T> tryParse, string typeName)
            {
                if (tryParse(input, out var result))
                    return result;

                throw new System.FormatException($"Failed to parse '{input}' as {typeName}");
            }

            private static T TryParseWithCustomParser<T>(string input, System.Func<string, T> parser)
            {
                try
                {
                    return parser(input);
                }
                catch (System.Exception ex)
                {
                    throw new System.FormatException($"Custom parser failed to parse '{input}': {ex.Message}", ex);
                }
            }

            private static object TryConvertOrThrow(string input, System.Type targetType, string typeName)
            {
                try
                {
                    return System.Convert.ChangeType(input, targetType);
                }
                catch (System.Exception ex)
                {
                    throw new System.FormatException($"Failed to convert '{input}' to {typeName}: {ex.Message}", ex);
                }
            }
            """);
    }

    private static void SetPositionalValue(IndentedTextWriter writer, PositionalArgumentModel argument)
    {
        switch (argument.MemberType)
        {
            case IArrayTypeSymbol { ElementType: { } elementType }:
            {
                ArgumentConversionHelper.WriteArraySetter(writer, argument.VariableName, elementType, argument.ValueParser, isNamed: false);
                break;
            }

            case INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol:
            {
                var elementType = namedTypeSymbol.TypeArguments.First();
                writer.WriteMultiLine(
                    $"""
                     const int MaxListElements = 10000;
                     if (!{argument.VariableName}.HasValue)
                         {argument.VariableName} = new System.Collections.Generic.List<{elementType}>();

                     if ({argument.VariableName}.Value.Count >= MaxListElements)
                         throw new System.ArgumentException("List argument exceeds maximum of " + MaxListElements + " elements");

                     {argument.VariableName}.Value.Add({ArgumentConversionHelper.GetArgConversion(elementType, "value", argument.ValueParser)});
                     index++;
                     """);
                break;
            }

            default:
            {
                var fullTypeName = argument.MemberType.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
                var conversion = ArgumentConversionHelper.GetArgConversion(argument.MemberType, "value", argument.ValueParser);

                if (argument.ValidationAttributes.Length > 0)
                {
                    writer.WriteLine("var value = valueLiteral.Value;");
                    writer.WriteLine($"var parsedValue = {conversion};");
                    ValidationCodeGenerator.GenerateValidationCode(writer, argument, "parsedValue");
                    writer.WriteMultiLine(
                        $"""
                         {argument.VariableName} = parsedValue;
                         index++;
                         """);
                }
                else
                {
                    writer.WriteMultiLine(
                        $"""
                         var value = valueLiteral.Value;
                         {argument.VariableName} = {conversion};
                         index++;
                         """);
                }
                break;
            }
        }
    }

    private static void SetNamedArgumentValue(IndentedTextWriter writer, NamedArgumentModel argument)
    {
        var symbolName = argument.Symbol.Name.ToSnakeCase();

        if (argument.MemberType.Name is "Boolean")
        {
            writer.WriteLine(
                "if (index < tokens.Length - 1 && tokens[index] is Clap.Net.ValueLiteral(var value) && bool.TryParse(value.ToString(), out var b))");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"{argument.VariableName} = b;");
            writer.WriteLine("index++;");
            writer.WriteLine("break;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"{argument.VariableName} = true;");
            return;
        }

        writer.WriteLine("if (index >= tokens.Length || tokens[index] is not Clap.Net.ValueLiteral(var value))");
        writer.Indent++;
        writer.WriteLine(
            $"return new Clap.Net.Models.ParseError(\"Expected value to follow named arg '{symbolName}'\", GetFormattedHelpMessage());");
        writer.Indent--;
        writer.WriteLine();

        switch (argument)
        {
            case { Action: ArgAction.Count }:
                writer.WriteMultiLine(
                    $$"""
                      if (int.TryParse(value, out var i))
                      {
                          {{argument.VariableName}} = i;
                          index++;
                          break;
                      }

                      // If a value is not given then we should treat this as
                      {{argument.VariableName}} = {{argument.VariableName}}.Value + 1;
                      """);
                break;

            case { MemberType: IArrayTypeSymbol { ElementType: { } elementType } }:
            {
                ArgumentConversionHelper.WriteArraySetter(writer, argument.VariableName, elementType, argument.ValueParser, isNamed: true);
                break;
            }

            case { MemberType: INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol }:
            {
                var elementType = namedTypeSymbol.TypeArguments.First();
                writer.WriteMultiLine(
                    $"""
                     const int MaxListElements = 10000;
                     if (!{argument.VariableName}.HasValue)
                         {argument.VariableName} = new System.Collections.Generic.List<{elementType}>();

                     if ({argument.VariableName}.Value.Count >= MaxListElements)
                         throw new System.ArgumentException("List argument exceeds maximum of " + MaxListElements + " elements");

                     {argument.VariableName}.Value.Add({ArgumentConversionHelper.GetArgConversion(elementType, "value", argument.ValueParser)});
                     index++;
                     """);
                break;
            }

            default:
            {
                var fullTypeName = argument.MemberType.ToDisplayString(CodeGeneratorConstants.FullNameDisplayFormat);
                var conversion = ArgumentConversionHelper.GetArgConversion(argument.MemberType, "value", argument.ValueParser);

                if (argument.ValidationAttributes.Length > 0)
                {
                    writer.WriteLine($"var parsedValue = {conversion};");
                    ValidationCodeGenerator.GenerateValidationCode(writer, argument, "parsedValue");
                    writer.WriteMultiLine(
                        $"""
                         {argument.VariableName} = parsedValue;
                         index++;
                         """);
                }
                else
                {
                    writer.WriteMultiLine(
                        $"""
                         {argument.VariableName} = {conversion};
                         index++;
                         """);
                }
                break;
            }
        }
    }
}