using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using Clap.Net.Extensions;
using Clap.Net.Models;
using Clap.Net.Serialisation;
using Microsoft.CodeAnalysis;

namespace Clap.Net.Generators;

internal static class CommandCodeGenerator
{
    private static readonly SymbolDisplayFormat FullNameDisplayString =
        new(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);

    public static void GenerateSourceCode(
        IndentedTextWriter writer,
        SyntaxBuilder syntaxBuilder,
        CommandModel commandModel,
        ImmutableArray<SubCommandModel> subCommandModels,
        string? assembly)
    {
        var namedArgs = commandModel.Arguments.OfType<NamedArgumentModel>().ToArray();
        var positionalArgs = commandModel.Arguments.OfType<PositionalArgumentModel>().ToArray();

        var fullName = commandModel.Symbol.ToDisplayString(FullNameDisplayString);
        var subCommand = commandModel.SubCommandArgumentModel is { } c
            ? FindSubCommand(c.MemberType, subCommandModels)
            : null;

        WriteCommentHeader(commandModel, writer, syntaxBuilder);

        if (!commandModel.Symbol.ContainingNamespace.IsGlobalNamespace)
            syntaxBuilder.BlockScopeNamespace(commandModel.Symbol.ContainingNamespace);

        using var containerType = commandModel.Symbol.ContainingType is { } containingType
            ? syntaxBuilder.TypeDefinition(containingType)
            : null;

        using var typeBuilder = syntaxBuilder.TypeDefinition(commandModel.Symbol);

        writer.WriteLine("private const string HelpMessage = ");
        writer.Indent++;
        writer.WriteLine("\"\"\"");
        writer.WriteMultiLine(GenerateHelpMessage(commandModel, subCommand, namedArgs, positionalArgs));
        writer.WriteLine("\"\"\";");
        writer.Indent--;
        writer.WriteLine();

        GenerateSpanParseMethod(writer, fullName);
        writer.WriteLine();

        GenerateTokenParseMethod(writer, fullName);
        writer.WriteLine();

        WriteSpanTryParseMethod(typeBuilder, writer, fullName);
        writer.WriteLine();

        WriteTokenTryParseMethod(
            typeBuilder, commandModel, assembly, writer, namedArgs, positionalArgs, fullName, subCommand);
        writer.WriteLine();

        WriteHelperMethods(writer);
    }

    private static void WriteCommentHeader(
        CommandModel commandModel,
        IndentedTextWriter writer,
        SyntaxBuilder syntaxBuilder)
    {
        syntaxBuilder.WriteMultiLineComment(
            $"""
             CAUTION! This code has been generated by the Clap.Net source generator and should not be edited.

             Name: {commandModel.Name}
             About: {commandModel.About}
             Long About: {commandModel.LongAbout}
             """);
        writer.WriteLine();
        syntaxBuilder.WriteNullable();
        writer.WriteLine();
    }

    private static void GenerateSpanParseMethod(IndentedTextWriter writer, string fullName)
    {
        writer.WriteMultiLine(
            $$"""
              public static {{fullName}} Parse(System.ReadOnlySpan<string> args)
              {
                  var tokens = Clap.Net.Lexer.Lex(args);
                  return Parse(tokens);
              }
              """);
    }

    private static void GenerateTokenParseMethod(IndentedTextWriter writer, string fullName)
    {
        writer.WriteMultiLine(
            $$"""
              public static {{fullName}} Parse(System.ReadOnlySpan<Clap.Net.IToken> tokens)
              {
                  switch (TryParse(tokens))
                  {
                      case { IsT0: true, AsT0: var result }:
                          return result;

                      case { IsT2: true, AsT2: { Version: var version } }:
                          System.Console.WriteLine(version);
                          System.Environment.Exit(0);
                          break;

                      case { IsT3: true, AsT3: { Message: var message, HelpMessage: var helpMessage } }:
                          DisplayError(message, helpMessage);
                          System.Environment.Exit(0);
                          break;

                      // Includes ShowHelp
                      default:
                          PrintHelpMessage();
                          System.Environment.Exit(0);
                          break;
                  }

                  return default!; // Just to shut the compiler up
              }
              """);
    }

    private static void WriteSpanTryParseMethod(
        TypeSyntaxBuilder typeBuilder,
        IndentedTextWriter writer,
        string fullName)
    {
        using var method = typeBuilder.Method(
            BindingFlags.Public | BindingFlags.Static,
            $"Clap.Net.Models.ParseResult<{fullName}>",
            "TryParse",
            ["System.ReadOnlySpan<string> args"]);

        writer.WriteLine("var tokens = Clap.Net.Lexer.Lex(args);");
        writer.WriteLine("return TryParse(tokens);");
    }

    private static void WriteTokenTryParseMethod(
        TypeSyntaxBuilder typeBuilder,
        CommandModel commandModel,
        string? assemblyVersion,
        IndentedTextWriter writer,
        NamedArgumentModel[] namedArguments,
        PositionalArgumentModel[] positionalArgs,
        string fullName,
        SubCommandModel? subCommand)
    {
        using var method = typeBuilder.Method(
            BindingFlags.Public | BindingFlags.Static,
            $"Clap.Net.Models.ParseResult<{fullName}>",
            "TryParse",
            ["System.ReadOnlySpan<Clap.Net.IToken> tokens"]);

        using (method.If("tokens.Length > 0 && tokens[0] is Clap.Net.ShortFlag('h') or Clap.Net.LongFlag(\"help\")"))
            writer.WriteLine("return new Clap.Net.Models.ShowHelp();");

        writer.WriteLine();

        if ((commandModel.Version ?? assemblyVersion) is { } version)
        {
            var versionFlags = new List<string>();

            if (namedArguments.All(_ => _.Short != 'v'))
                versionFlags.Add("Clap.Net.ShortFlag('v')");

            if (namedArguments.All(_ => _.Long != "version"))
                versionFlags.Add("Clap.Net.LongFlag(\"version\")");

            if (versionFlags.Any())
            {
                writer.Write("if (tokens.Length > 0 && tokens[0] is ");
                writer.Write(string.Join(" or ", versionFlags));
                writer.WriteLine(')');
                writer.WriteMultiLine(
                    $$"""
                      {
                          return new Clap.Net.Models.ShowVersion("{{version}}");
                      }
                      """);
                writer.WriteLine();
            }
        }

        if (commandModel.Arguments.Length is 0 && commandModel.SubCommandArgumentModel is null)
        {
            writer.WriteLine($"return new {fullName}();");
            return;
        }

        foreach (var arg in namedArguments)
        {
            writer.Write($"// Argument '{arg.Symbol.Name}' is a");
            if (arg.Required) writer.Write(" required");
            writer.WriteLine(" named argument");

            var type = arg.MemberType.ToDisplayString(FullNameDisplayString);
            if (arg.MemberType is INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol)
            {
                var elementType = namedTypeSymbol.TypeArguments.First().ToDisplayString(FullNameDisplayString);
                type = $"System.Collections.Generic.List<{elementType}>";
            }

            var initialValue = arg switch
            {
                { DefaultValue: { } value } => $"({type}){value}",
                { Required: true } => $"new Clap.Net.Models.FieldValue<{type}>()",
                _ => $"({type})default"
            };

            var defaultValue = arg.Env is { } env
                ? $"Environment.GetEnvironmentVariable(\"{env}\") is {{ }} env ? ({type}){GetArgConversion(arg.MemberType, "env")} : {initialValue}"
                : initialValue;

            writer.WriteLine($"Clap.Net.Models.FieldValue<{type}> {arg.VariableName} = {defaultValue};");
        }

        foreach (var arg in commandModel.Arguments.OfType<PositionalArgumentModel>())
        {
            var type = arg.MemberType.ToDisplayString(FullNameDisplayString);
            var defaultValue = arg switch
            {
                { DefaultValue: { } value } => $"({type}){value}",
                { Required: true } => $"new Clap.Net.Models.FieldValue<{type}>()",
                _ => $"({type})default!"
            };

            writer.Write($"// Argument '{arg.Symbol.Name}' is");
            if (arg.Required) writer.Write(" a required");
            writer.WriteLine($" positional argument at index {arg.Index}");

            writer.WriteLine($"Clap.Net.Models.FieldValue<{type}> {arg.VariableName} = {defaultValue};");
        }

        if (commandModel.SubCommandArgumentModel is { } subCommandArgument)
        {
            writer.WriteLine();

            var type = subCommandArgument.MemberType.ToDisplayString(FullNameDisplayString);
            var defaultValue = subCommandArgument switch
            {
                { DefaultValue: { } value } => $"({type}){value}",
                { IsRequired: true } => "null",
                _ => $"({type})default!"
            };

            method.SingleLineComment($"SubCommand '{subCommandArgument.Symbol.Name}'");
            writer.WriteLine($"Clap.Net.Models.ParseResult<{type}>? @___subCommand = {defaultValue};");
        }

        writer.WriteLine();

        if (positionalArgs.Length > 0)
            writer.WriteLine("var positionalIndex = 0;");

        writer.WriteLine("var index = 0;");

        using (var whileBlock = method.WhileStatement("index < tokens.Length"))
        using (var tokenSwitch = whileBlock.SwitchStatement("tokens[index]"))
        {
            if (subCommand is not null)
                GenerateSubCommandCase(writer, tokenSwitch, subCommand);

            GenerateFlagCase(commandModel, tokenSwitch, writer);

            foreach (var argument in commandModel.Arguments)
            {
                switch (argument)
                {
                    case NamedArgumentModel value:
                    {
                        GenerateNamedArgumentCase(writer, fullName, value, argument);
                        break;
                    }

                    case PositionalArgumentModel positional:
                    {
                        GeneratePositionalArgumentModel(writer, fullName, positional);
                        break;
                    }
                }
            }

            using (tokenSwitch.Case("var arg"))
                writer.WriteLine(
                    "return new Clap.Net.Models.ParseError($\"Unknown argument '{Clap.Net.TokenExtensions.Format(arg)}'\", GetFormattedHelpMessage());");
        }

        writer.WriteLine();

        GenerateRequiredArgumentChecks(commandModel, method, writer);

        writer.WriteLine();
        writer.Write("return ");

        using var obj = method.NewObject(fullName);

        foreach (var arg in commandModel.Arguments)
            obj.WriteField(arg.Symbol.Name, $"{arg.VariableName}.Value");

        if (commandModel.SubCommandArgumentModel is not null)
            obj.WriteField(commandModel.SubCommandArgumentModel.Symbol.Name, "@___subCommand.AsT0");
    }

    private static void GenerateRequiredArgumentChecks(
        CommandModel commandModel,
        BlockSyntaxBuilder syntaxBuilder,
        IndentedTextWriter writer)
    {
        var requiredArguments = commandModel.Arguments
            .Where(a => a.Required)
            .ToArray();

        if (requiredArguments.Length > 0)
        {
            var condition = string.Join(" || ", requiredArguments.Select(a => $"!{a.VariableName}.HasValue"));

            using var ifBlock = syntaxBuilder.If(condition);
            writer.WriteLine("var sb = new System.Text.StringBuilder();");

            foreach (var requiredArg in requiredArguments)
            {
                var name = requiredArg.VariableName;
                switch (requiredArg)
                {
                    case { Symbol: IArrayTypeSymbol }:
                    {
                        using (ifBlock.If($"!{name}.HasValue || {name}.Value.Length is 0"))
                            writer.WriteLine($"sb.AppendLine(\"  <{requiredArg.Symbol.Name}>\");");
                        break;
                    }

                    default:
                    {
                        using (ifBlock.If($"!{name}.HasValue"))
                            writer.WriteLine($"sb.AppendLine(\"  <{requiredArg.Symbol.Name}>\");");
                        break;
                    }
                }
            }

            writer.WriteLine(
                "return new Clap.Net.Models.ParseError($\"The following required arguments were not provided:\\n{sb.ToString()}\", GetFormattedHelpMessage());");
        }
        else
        {
            writer.WriteLine("// No required fields");
        }

        if (commandModel.SubCommandArgumentModel is not { IsRequired: true })
            return;

        using (syntaxBuilder.If("@___subCommand is null"))
            writer.WriteLine(
                $"return new Clap.Net.Models.ParseError($\"The subcommand was not provided:\\n{commandModel.SubCommandArgumentModel.Symbol.Name}\", GetFormattedHelpMessage());");
    }

    private static void GeneratePositionalArgumentModel(
        IndentedTextWriter writer,
        string fullName,
        PositionalArgumentModel positional)
    {
        writer.WriteLine($"// Setting attribute '{fullName}.{positional.Symbol.Name}'");
        writer.WriteLine($"case Clap.Net.ValueLiteral valueLiteral when positionalIndex is {positional.Index}:");
        writer.WriteLine("{");
        writer.Indent++;
        SetPositionalValue(writer, positional);
        writer.WriteLine("positionalIndex++;");
        writer.WriteLine("break;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private static void GenerateNamedArgumentCase(
        IndentedTextWriter writer,
        string fullName,
        NamedArgumentModel value,
        ArgumentModel argument)
    {
        var symbolName = value.Symbol.Name.ToSnakeCase();
        var name = value switch
        {
            { Short: { } shortName, Long: { } longName } =>
                $"Clap.Net.ShortFlag('{shortName}') or Clap.Net.LongFlag(\"{longName}\")",
            { Short: { } shortName } => $"Clap.Net.ShortFlag('{shortName}')",
            { Long: { } longName } => $"Clap.Net.LongFlag(\"{longName}\")",
            _ => $"Clap.Net.LongFlag(\"{symbolName}\")"
        };

        writer.WriteLine($"// Setting named argument '{fullName}.{value.Symbol.Name}'");
        writer.WriteLine($"// action '{value.Action.ToString()}'");
        writer.WriteLine($"case {name}:");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("index++;");
        SetNamedArgumentValue(writer, value);
        writer.WriteLine("break;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        if (argument.MemberType.Name is "Boolean"
            && value is { Negation: true, Long: { } l })
        {
            writer.WriteLine($"// Setting attribute '{fullName}.{value.Symbol.Name}'");
            writer.WriteLine($"case NegatedFlag(Clap.Net.LongFlag(\"{l}\")):");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("index++;");
            writer.WriteLine($"{value.VariableName} = false;");
            writer.WriteLine("break;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
        }
    }

    private static void GenerateSubCommandCase(
        IndentedTextWriter writer,
        SwitchStatementSyntaxBuilder syntaxBuilder,
        SubCommandModel subCommand)
    {
        var type = subCommand.Symbol.ToDisplayString(FullNameDisplayString);
        writer.WriteMultiLine(
            $"""
            // Setting subcommand '{type}'
            // Command switching swallows the rest of the arguments but previously
            // parsed arguments still get applied to the model
            """);

        var names = new string[subCommand.Commands.Count];
        for (var i = 0; i < subCommand.Commands.Count; i++)
            names[i] = $"\"{subCommand.Commands[i].Name}\"";

        using var caseBlock = syntaxBuilder.Case($"Clap.Net.ValueLiteral({string.Join(" or ", names)})");

        using (var resolveSwitch = caseBlock.SwitchStatement($"{type}.Resolve(tokens[index..])"))
        {
            using (resolveSwitch.Case("{ IsT0: true } t0"))
            {
                caseBlock.Assignment("@___subCommand", "t0.AsT0");
                caseBlock.Break();
            }

            using (resolveSwitch.Case("{ IsT1: true } t1"))
                writer.WriteLine("return t1.AsT1;");

            using (resolveSwitch.Case("{ IsT2: true } t2"))
                writer.WriteLine("return t2.AsT2;");

            using (resolveSwitch.Case("{ IsT3: true } t3"))
                writer.WriteLine("return t3.AsT3;");
        }

        writer.WriteLine();

        caseBlock.SingleLineComment("Jump to the end of the token list");
        caseBlock.Assignment("index", "tokens.Length");
        caseBlock.Break();
    }

    private static void GenerateFlagCase(
        CommandModel commandModel,
        SwitchStatementSyntaxBuilder switchSyntaxBuilder,
        IndentedTextWriter writer)
    {
        writer.WriteLine("// Handling CompoundFlag");
        using var compountFlagCase = switchSyntaxBuilder.Case("Clap.Net.CompoundFlag(var chars)");

        using (var forEachBlock = compountFlagCase.ForEachBlock("c", "chars"))
        using (var caseStatement = forEachBlock.SwitchStatement("c"))
        {
            foreach (var arg in commandModel.Arguments
                         .OfType<NamedArgumentModel>()
                         .Where(a => a.Short is not null))
            {
                switch (arg.MemberType.Name)
                {
                    case "Boolean":
                    {
                        using (caseStatement.Case($"'{arg.Short!.Value}'"))
                        {
                            writer.WriteLine($"{arg.VariableName} = true;");
                            writer.WriteLine("break;");
                        }

                        break;
                    }

                    case "Int32" or "Int64":
                    {
                        using (caseStatement.Case($"'{arg.Short!.Value}'"))
                        {
                            writer.WriteLine($"{arg.VariableName} = {arg.VariableName}.Value + 1;");
                            writer.WriteLine("break;");
                        }

                        break;
                    }
                }
            }

            using (caseStatement.DefaultCase())
                writer.WriteLine(
                    "return new Clap.Net.Models.ParseError($\"Unexpected flag supplied in compound flags '{c}'\", GetFormattedHelpMessage());");
        }

        writer.WriteLine("index++;");
        writer.WriteLine("break;");
    }

    private static SubCommandModel? FindSubCommand(
        ITypeSymbol member,
        ImmutableArray<SubCommandModel> subCommandModels)
    {
        var memberType = member.ToDisplayString().TrimEnd('?');
        return subCommandModels.FirstOrDefault(sc =>
            memberType == sc?.Symbol.ToDisplayString(FullNameDisplayString).TrimEnd('?'));
    }

    private static string GenerateHelpMessage(
        CommandModel commandModel,
        SubCommandModel? subCommand,
        NamedArgumentModel[] namedArguments,
        PositionalArgumentModel[] positionalArgs)
    {
        var sb = new StringBuilder();

        var about = commandModel.LongAbout ?? commandModel.About;
        if (!string.IsNullOrEmpty(about))
        {
            sb.AppendLine(about!.Trim());
            sb.AppendLine();
        }

        sb.Append("Usage: {{EXECUTABLE_NAME}}");

        if (commandModel is { IsSubCommand: true, Name: not null })
            sb.Append($" {commandModel.Name}");

        if (namedArguments.Any())
            sb.Append(" [OPTIONS]");

        foreach (var positional in positionalArgs)
            sb.Append($" <{positional.Symbol.Name}>");
        sb.AppendLine();

        var table = new List<string?[]>();

        if (positionalArgs.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("Arguments:");
            foreach (var positional in positionalArgs)
                table.Add([$"<{positional.Symbol.Name}>", positional.Help]);

            var maxArgLength = table.Max(o => o[0]?.Length ?? 0);
            foreach (var row in table)
                sb.AppendLine($"  {row[0]?.PadRight(maxArgLength)}  {row[1]}");

            table.Clear();
        }

        foreach (var option in namedArguments)
        {
            var names = option switch
            {
                { Short: { } shortName, Long: { } longName } => $"-{shortName}, --{longName}",
                { Short: { } shortName } => $"-{shortName}",
                { Long: { } longName } => $"--{longName}",
                _ => $"{option.Symbol.Name.ToSnakeCase()}"
            };

            table.Add([names, option.Help]);
        }

        table.Add(["-h, --help", "Shows this help message"]);

        var maxColumnLength = table.Max(o => o[0]?.Length ?? 0);

        sb.AppendLine();
        sb.AppendLine("Options:");
        foreach (var row in table)
            sb.AppendLine($"  {row[0]?.PadRight(maxColumnLength)}  {row[1]}");
        table.Clear();

        if (subCommand is { Commands.Count: > 0 })
        {
            foreach (var command in subCommand.Commands)
                table.Add([command.Name, command.About]);

            maxColumnLength = table.Max(o => o[0]?.Length ?? 0);

            sb.AppendLine();
            sb.AppendLine("Commands:");
            foreach (var row in table)
                sb.AppendLine($"  {row[0]?.PadRight(maxColumnLength)}  {row[1]}");
        }

        return sb.ToString();
    }

    private static void WriteHelperMethods(IndentedTextWriter writer)
    {
        writer.WriteMultiLine(
            """
            public static void DisplayError(string message, string helpMessage)
            {
                var previousColour = System.Console.ForegroundColor;
                System.Console.ForegroundColor = System.ConsoleColor.Red;
                System.Console.WriteLine($"{message}");
                System.Console.ForegroundColor = previousColour;
                System.Console.WriteLine(helpMessage);
            }

            private static void PrintHelpMessage() 
            {
                System.Console.WriteLine(GetFormattedHelpMessage());
            }

            private static string GetFormattedHelpMessage() 
            {
                var executableName = System.IO.Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]);
                if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows))
                    executableName += "[.exe]";
                return HelpMessage.Replace("{{EXECUTABLE_NAME}}", executableName);
            }
            """);
    }

    private static void SetPositionalValue(IndentedTextWriter writer, PositionalArgumentModel argument)
    {
        switch (argument.MemberType)
        {
            case IArrayTypeSymbol { ElementType: { } elementType }:
            {
                WriteArraySetter(writer, argument.VariableName, elementType);
                break;
            }

            case INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol:
            {
                var elementType = namedTypeSymbol.TypeArguments.First();
                writer.WriteMultiLine(
                    $"""
                     if (!{argument.VariableName}.HasValue)
                         {argument.VariableName} = new System.Collections.Generic.List<{elementType}>();

                     {argument.VariableName}.Value.Add({GetArgConversion(elementType, "value")});
                     index++;
                     """);
                break;
            }

            default:
                writer.WriteMultiLine(
                    $"""
                     var value = valueLiteral.Value;
                     {argument.VariableName} = {GetArgConversion(argument.MemberType, "value")};
                     index++;
                     """);
                break;
        }
    }

    private static void SetNamedArgumentValue(IndentedTextWriter writer, NamedArgumentModel argument)
    {
        var symbolName = argument.Symbol.Name.ToSnakeCase();

        if (argument.MemberType.Name is "Boolean")
        {
            writer.WriteLine(
                "if (index < tokens.Length - 1 && tokens[index] is Clap.Net.ValueLiteral(var value) && bool.TryParse(value.ToString(), out var b))");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"{argument.VariableName} = b;");
            writer.WriteLine("index++;");
            writer.WriteLine("break;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"{argument.VariableName} = true;");
            return;
        }

        writer.WriteLine("if (index > tokens.Length - 1 || tokens[index] is not Clap.Net.ValueLiteral(var value))");
        writer.Indent++;
        writer.WriteLine(
            $"return new Clap.Net.Models.ParseError(\"Expected value to follow named arg '{symbolName}'\", GetFormattedHelpMessage());");
        writer.Indent--;
        writer.WriteLine();

        switch (argument)
        {
            case { Action: ArgAction.Count }:
                writer.WriteMultiLine(
                    $$"""
                      if (int.TryParse(value, out var i))
                      {
                          {{argument.VariableName}} = i;
                          index++;
                          break;
                      }

                      // If a value is not given then we should treat this as
                      {{argument.VariableName}} = {{argument.VariableName}}.Value + 1;
                      """);
                break;

            case { MemberType: IArrayTypeSymbol { ElementType: { } elementType } }:
            {
                WriteArraySetter(writer, argument.VariableName, elementType);
                break;
            }

            case { MemberType: INamedTypeSymbol { Name: "IEnumerable" } namedTypeSymbol }:
            {
                var elementType = namedTypeSymbol.TypeArguments.First();
                writer.WriteMultiLine(
                    $"""
                     if (!{argument.VariableName}.HasValue)
                         {argument.VariableName} = new System.Collections.Generic.List<{elementType}>();
                     {argument.VariableName}.Value.Add({GetArgConversion(elementType, "value")});
                     index++;
                     """);
                break;
            }

            default:
                writer.WriteMultiLine(
                    $"""
                     {argument.VariableName} = {GetArgConversion(argument.MemberType, "value")};
                     index++;
                     """);
                break;
        }
    }

    private static void WriteArraySetter(IndentedTextWriter writer, string variableName, ITypeSymbol elementType)
    {
        var childType = elementType.ToDisplayString(FullNameDisplayString);
        writer.WriteMultiLine(
            $$"""
              var builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<{{childType}}>();
              while (index < tokens.Length && tokens[index] is Clap.Net.ValueLiteral(var @____value)) 
              {
                  builder.Add({{GetArgConversion(elementType, "@____value")}});
                  index++;
              }
              {{variableName}} = builder.ToArray();
              """);
    }

    private static string GetArgConversion(ITypeSymbol member, string variableName)
    {
        var nullable = member.NullableAnnotation is NullableAnnotation.Annotated;
        var fullName = member.ToDisplayString(FullNameDisplayString);
        return member.Name switch
        {
            "String" => variableName,
            "Int32" => nullable
                ? $"int.TryParse({variableName}, out var v) ? v : null"
                : $"int.Parse({variableName})",
            "Int64" => nullable
                ? $"long.TryParse({variableName}, out var v) ? v : null"
                : $"long.Parse({variableName})",
            "Single" => nullable
                ? $"float.TryParse({variableName}, out var v) ? v : null"
                : $"float.Parse({variableName})",
            "Double" => nullable
                ? $"double.TryParse({variableName}, out var v) ? v : null"
                : $"double.Parse({variableName})",
            "Decimal" => nullable
                ? $"decimal.TryParse({variableName}, out var v) ? v : null"
                : $"decimal.Parse({variableName})",
            "Boolean" => nullable
                ? $"bool.TryParse({variableName}, out var v) ? v : null"
                : $"bool.Parse({variableName})",
            "Byte" => nullable
                ? $"byte.TryParse({variableName}, out var v) ? v : null"
                : $"byte.Parse({variableName})",
            "SByte" => nullable
                ? $"sbyte.TryParse({variableName}, out var v) ? v : null"
                : $"sbyte.Parse({variableName})",
            "Int16" => nullable
                ? $"short.TryParse({variableName}, out var v) ? v : null"
                : $"short.Parse({variableName})",
            "UInt16" => nullable
                ? $"ushort.TryParse({variableName}, out var v) ? v : null"
                : $"ushort.Parse({variableName})",
            "UInt32" => nullable
                ? $"uint.TryParse({variableName}, out var v) ? v : null"
                : $"uint.Parse({variableName})",
            "UInt64" => nullable
                ? $"ulong.TryParse({variableName}, out var v) ? v : null"
                : $"ulong.Parse({variableName})",
            "Char" => nullable
                ? $"char.TryParse({variableName}, out var v) ? v : null"
                : $"char.Parse({variableName})",
            "DateTime" => nullable
                ? $"DateTime.TryParse({variableName}, out var v) ? v : null"
                : $"DateTime.Parse({variableName})",
            "TimeSpan" => nullable
                ? $"TimeSpan.TryParse({variableName}, out var v) ? v : null"
                : $"TimeSpan.Parse({variableName})",
            "Guid" => nullable
                ? $"Guid.TryParse({variableName}, out var v) ? v : null"
                : $"Guid.Parse({variableName})",
            _ => $"({fullName})Convert.ChangeType({variableName}, typeof({fullName}))"
        };
    }
}